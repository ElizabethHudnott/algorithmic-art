<div id="about">
	<p>
		<span class="sketch-title">Cellular Automata</span> explores how simple mechanized rules operating on a local level can produce organized structures on a global level. The screen is divided into a grid of cells and each cell gets placed into one of a fixed number of states. In a two-state automaton the two states are known as State&nbsp;0 and State&nbsp;1 and these are represented visually by a blank space and a coloured rectangle respectively. For a cellular automaton having more than two states State&nbsp;0 is still represented by a blank space but the other states are distinguished by giving each state its own colour.
	</p>
	<p>
		The top row of cells are the seed cells. You can place these cells into whatever states you like. By default the sketch uses a seed row consisting of just one or two cells placed into State&nbsp;1 and the rest are in State&nbsp;0. The states of the cells on the rows beneath are constructed entirely mechanically according to the chosen rule.
	</p>
	<p>
		Every cell (apart from those in the seed row) has a <dfn>neighbourhood</dfn> of cells that are able to influence its own state. The states of the other cells within the neighbourhood of the cell whose value is currently being computed act as input data into the computational rule. Normally, for the one-dimensional cellular automata that this sketch focuses on the neighbourhood consists of the cell directly above the current cell, the cell above and one step to the left, and the cell above and to the right. You can enlarge the neighbourhood by adding a forth cell from two rows directly above the current cell. This forth cell is known as a <dfn>memory cell</dfn>. Two and three-dimensional automata also exist but aren't included in this sketch. If you're wondering how a 1D automaton produces a 2D picture, each row successively added down the page represents a step forward in "time".
	</p>
	<p>
		An automaton's rule can be any rule that has three (or four) inputs, each of which is a number between zero and the chosen number of permitted states minus one, and produces an output which is a number in the same range. For automata which have two possible cell states and a neighbourhood made up of three cells there are 2<sup>3</sup>&nbsp;=&nbsp;8 possible combinations of input data. For each of those combinations there are two possible outputs, the current cell is either placed in State&nbsp;0 or in State&nbsp;1. Which value is the correct output depends on the rule obeyed by the particular automaton but in total there are 2<sup>8</sup>&nbsp;=&nbsp;256 possible rules we can construct for a 1D automaton with two states and a three cell neighbourhood. In principle you could describe an automaton's rule using any reasonable description but conventionally they're known by their <a href="https://mathworld.wolfram.com/ElementaryCellularAutomaton.html" target="_blank" rel="noopener">catalogue</a> number, for example Rule&nbsp;18 produces a set of recursive triangular shapes and forms the starting point for this sketch.
	</p>
	<p>
		Did you notice how even for a fairly minimal case with only one dimension, two states and a three cell neighbourhood we still ended up with a large number of possible rules (256)? There were eight possible input combinations but with three states there would be 3<sup>3</sup>&nbsp;=&nbsp;27 input combinations and our chosen rule would need to describe the output for each of those 27 combinations. We'd quite like to have more states and bigger neighbourhoods without having to produce giant tables of combinations of input values and their respective outputs (and a very large catalogue).
	</p>
	<p>
		Fortunately, we can devise categories of rules. We can decide that we're only willing to bother examining a rule if the rule itself obeys a particular rule! <a href="https://mathworld.wolfram.com/TotalisticCellularAutomaton.html" target="_blank" rel="noopener">Totalistic automata</a> are a good example. These take the states of the cells in the neighbourhood and add them up. There are 3&nbsp;&times; (<var>k</var>&nbsp;- 1) + 1 possible values for the sum obtained from a three cell neighbourhood with <var>k</var> states. For a three state automaton we've reduced 27 different input combinations down to seven possible values for the sum (0 to 6). We still have to choose an output state for each of these seven values but by deciding the automaton is totalistic we have a way of enjoying freedom to experiment without having to deal directly with a burdensome number of input combinations.
	</p>
</div>
